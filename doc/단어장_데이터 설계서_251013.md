251013_설계 - 데이터베이스 스키마 설계서 v1.0.md
작성일: 2025-10-13
프로젝트명: 스마트 단어장 (Smart Vocabulary Builder)
작성자: AI Software Student Team
문서 유형: 설계 문서

1. 개요
1.1 설계 목적
단어장 프로그램의 데이터 저장 및 관리를 위한 데이터베이스 스키마를 정의한다.
1.2 데이터베이스 선택

DBMS: SQLite 3.x
저장 위치: data/vocabulary.db
인코딩: UTF-8

1.3 설계 원칙

정규화: 제3정규형(3NF)까지 정규화
성능: 자주 조회되는 통계는 비정규화 허용
확장성: 향후 기능 추가를 고려한 컬럼 예약
무결성: 외래 키 제약조건 및 CHECK 제약조건 적용


2. ERD (Entity Relationship Diagram)
mermaiderDiagram
    words ||--o{ learning_history : "학습됨"
    words ||--o{ word_statistics : "통계보유"
    words ||--o{ wrong_note : "오답등록"
    words ||--o{ exam_details : "시험출제"
    
    exam_history ||--o{ exam_details : "포함"
    exam_history ||--o{ wrong_note : "생성"
    
    words {
        INTEGER word_id PK
        TEXT english UK
        TEXT korean
        TEXT memo
        INTEGER is_favorite
        TEXT created_date
        TEXT modified_date
    }
    
    learning_history {
        INTEGER history_id PK
        INTEGER word_id FK
        TEXT study_date
        INTEGER is_correct
        REAL response_time
        TEXT study_type
    }
    
    word_statistics {
        INTEGER word_id PK_FK
        INTEGER total_attempts
        INTEGER correct_count
        INTEGER wrong_count
        TEXT last_study_date
        TEXT next_review_date
        REAL ease_factor
        INTEGER interval_days
    }
    
    exam_history {
        INTEGER exam_id PK
        TEXT exam_date
        TEXT exam_type
        INTEGER total_questions
        INTEGER correct_count
        REAL score
        INTEGER time_taken
    }
    
    exam_details {
        INTEGER detail_id PK
        INTEGER exam_id FK
        INTEGER word_id FK
        TEXT user_answer
        INTEGER is_correct
        REAL response_time
        INTEGER question_number
    }
    
    wrong_note {
        INTEGER note_id PK
        INTEGER word_id FK
        INTEGER exam_id FK
        TEXT added_date
        INTEGER is_resolved
    }
    
    user_settings {
        TEXT setting_key PK
        TEXT setting_value
        TEXT updated_at
    }

3. 데이터 항목 정의
3.1 공통 데이터 항목
항목명영문명타입길이설명고유번호idINTEGER-자동 증가 기본키생성일시created_dateTEXT19YYYY-MM-DD HH:MM:SS수정일시modified_dateTEXT19YYYY-MM-DD HH:MM:SS날짜dateTEXT19YYYY-MM-DD HH:MM:SS시간(초)time_secondsREAL-초 단위 시간 (소수점 2자리)불린값booleanINTEGER-0(False) 또는 1(True)
3.2 단어 관련 항목
항목명영문명타입길이설명단어IDword_idINTEGER-단어 고유 식별자영어단어englishTEXT100영어 단어 (대소문자 구분 없음)한국어뜻koreanTEXT500한국어 뜻 (복수 가능, 쉼표 구분)메모memoTEXT1000사용자 개인 메모즐겨찾기여부is_favoriteINTEGER-0(일반) 또는 1(즐겨찾기)
3.3 학습 관련 항목
항목명영문명타입길이설명학습이력IDhistory_idINTEGER-학습 이력 고유 식별자학습날짜study_dateTEXT19학습 수행 일시정답여부is_correctINTEGER-0(오답) 또는 1(정답)응답시간response_timeREAL-답변까지 걸린 시간(초)학습유형study_typeTEXT20flashcard, exam
3.4 통계 관련 항목
항목명영문명타입길이설명총시도횟수total_attemptsINTEGER-학습 시도 총 횟수정답횟수correct_countINTEGER-정답 맞춘 횟수오답횟수wrong_countINTEGER-오답 횟수마지막학습일last_study_dateTEXT19가장 최근 학습 일시다음복습일next_review_dateTEXT10다음 복습 예정일 (YYYY-MM-DD)난이도계수ease_factorREAL-SM-2 알고리즘용 (초기값 2.5)복습간격interval_daysINTEGER-다음 복습까지 일수
3.5 시험 관련 항목
항목명영문명타입길이설명시험IDexam_idINTEGER-시험 고유 식별자시험날짜exam_dateTEXT19시험 수행 일시시험유형exam_typeTEXT20short_answer, multiple_choice총문항수total_questionsINTEGER-전체 문제 개수정답개수correct_countINTEGER-맞춘 문제 개수점수scoreREAL-정답률 (0.0 ~ 100.0)소요시간time_takenINTEGER-시험 소요 시간(초)
3.6 시험 상세 항목
항목명영문명타입길이설명상세IDdetail_idINTEGER-시험 상세 고유 식별자문제번호question_numberINTEGER-문제 순서 (1, 2, 3...)사용자답변user_answerTEXT200사용자가 입력한 답
3.7 오답노트 관련 항목
항목명영문명타입길이설명노트IDnote_idINTEGER-오답 노트 고유 식별자추가날짜added_dateTEXT19오답 노트 추가 일시해결여부is_resolvedINTEGER-0(미해결) 또는 1(해결)
3.8 설정 관련 항목
항목명영문명타입길이설명설정키setting_keyTEXT50설정 항목 이름 (PK)설정값setting_valueTEXT500설정 값 (문자열로 저장)수정일시updated_atTEXT19설정 수정 일시

4. 테이블 스키마 정의
4.1 words (단어 정보)
용도: 단어의 기본 정보를 저장
컬럼명한글명데이터타입제약조건기본값설명word_id단어IDINTEGERPRIMARY KEY AUTOINCREMENT-고유 식별자english영어단어TEXTNOT NULL UNIQUE-영어 단어 (중복 불가)korean한국어뜻TEXTNOT NULL-한국어 뜻memo메모TEXTNULLNULL사용자 메모is_favorite즐겨찾기여부INTEGERNOT NULL CHECK(is_favorite IN (0,1))00:일반, 1:즐겨찾기created_date생성일TEXTNOT NULL-ISO 8601 형식modified_date수정일TEXTNULLNULLISO 8601 형식
인덱스:
sqlCREATE INDEX idx_words_english ON words(english);
CREATE INDEX idx_words_favorite ON words(is_favorite);
CREATE INDEX idx_words_created ON words(created_date);
샘플 데이터:
sqlINSERT INTO words (english, korean, memo, is_favorite, created_date) VALUES
('apple', '사과', '과일 종류', 0, '2025-10-13 10:00:00'),
('book', '책', NULL, 1, '2025-10-13 10:05:00'),
('computer', '컴퓨터', '전자기기', 0, '2025-10-13 10:10:00');

4.2 learning_history (학습 이력)
용도: 모든 학습 활동(플래시카드, 시험)의 이력을 기록
컬럼명한글명데이터타입제약조건기본값설명history_id이력IDINTEGERPRIMARY KEY AUTOINCREMENT-고유 식별자word_id단어IDINTEGERNOT NULL FOREIGN KEY-words.word_id 참조study_date학습날짜TEXTNOT NULL-ISO 8601 형식is_correct정답여부INTEGERNOT NULL CHECK(is_correct IN (0,1))-0:오답, 1:정답response_time응답시간REALNULLNULL초 단위 (소수점 2자리)study_type학습유형TEXTNOT NULL CHECK(study_type IN ('flashcard','exam'))-flashcard 또는 exam
외래 키 제약조건:
sqlFOREIGN KEY (word_id) REFERENCES words(word_id) ON DELETE CASCADE ON UPDATE CASCADE
인덱스:
sqlCREATE INDEX idx_learning_word ON learning_history(word_id);
CREATE INDEX idx_learning_date ON learning_history(study_date);
CREATE INDEX idx_learning_type ON learning_history(study_type);
CREATE INDEX idx_learning_correct ON learning_history(is_correct);
샘플 데이터:
sqlINSERT INTO learning_history (word_id, study_date, is_correct, response_time, study_type) VALUES
(1, '2025-10-13 11:00:00', 1, 3.5, 'flashcard'),
(1, '2025-10-13 11:02:00', 0, 5.2, 'flashcard'),
(2, '2025-10-13 11:05:00', 1, 2.8, 'flashcard');

4.3 word_statistics (단어별 통계)
용도: 각 단어의 학습 통계 및 복습 스케줄 관리
컬럼명한글명데이터타입제약조건기본값설명word_id단어IDINTEGERPRIMARY KEY FOREIGN KEY-words.word_id 참조total_attempts총시도횟수INTEGERNOT NULL CHECK(total_attempts >= 0)0학습 시도 총 횟수correct_count정답횟수INTEGERNOT NULL CHECK(correct_count >= 0)0정답 맞춘 횟수wrong_count오답횟수INTEGERNOT NULL CHECK(wrong_count >= 0)0오답 횟수last_study_date마지막학습일TEXTNULLNULLISO 8601 형식next_review_date다음복습일TEXTNULLNULLYYYY-MM-DD 형식ease_factor난이도계수REALNOT NULL CHECK(ease_factor >= 1.3)2.5SM-2 알고리즘용interval_days복습간격INTEGERNOT NULL CHECK(interval_days >= 0)0일 단위
외래 키 제약조건:
sqlFOREIGN KEY (word_id) REFERENCES words(word_id) ON DELETE CASCADE ON UPDATE CASCADE
인덱스:
sqlCREATE INDEX idx_stats_last_study ON word_statistics(last_study_date);
CREATE INDEX idx_stats_next_review ON word_statistics(next_review_date);
CREATE INDEX idx_stats_wrong_rate ON word_statistics(wrong_count, total_attempts);
샘플 데이터:
sqlINSERT INTO word_statistics (word_id, total_attempts, correct_count, wrong_count, last_study_date, next_review_date, ease_factor, interval_days) VALUES
(1, 10, 7, 3, '2025-10-13 11:02:00', '2025-10-15', 2.5, 2),
(2, 5, 5, 0, '2025-10-13 11:05:00', '2025-10-20', 2.6, 7),
(3, 0, 0, 0, NULL, NULL, 2.5, 0);
통계 계산 쿼리 예시:
sql-- 오답률 계산
SELECT 
    word_id,
    CASE 
        WHEN total_attempts = 0 THEN NULL
        ELSE ROUND((wrong_count * 100.0) / total_attempts, 2)
    END as wrong_rate
FROM word_statistics;

4.4 exam_history (시험 이력)
용도: 시험의 전체 결과 및 통계 저장
컬럼명한글명데이터타입제약조건기본값설명exam_id시험IDINTEGERPRIMARY KEY AUTOINCREMENT-고유 식별자exam_date시험날짜TEXTNOT NULL-ISO 8601 형식exam_type시험유형TEXTNOT NULL CHECK(exam_type IN ('short_answer','multiple_choice'))-단답형/객관식total_questions총문항수INTEGERNOT NULL CHECK(total_questions > 0)-전체 문제 개수correct_count정답개수INTEGERNOT NULL CHECK(correct_count >= 0)-맞춘 문제 개수score점수REALNOT NULL CHECK(score >= 0 AND score <= 100)-정답률 (0~100)time_taken소요시간INTEGERNULLNULL초 단위
인덱스:
sqlCREATE INDEX idx_exam_date ON exam_history(exam_date);
CREATE INDEX idx_exam_type ON exam_history(exam_type);
CREATE INDEX idx_exam_score ON exam_history(score);
샘플 데이터:
sqlINSERT INTO exam_history (exam_date, exam_type, total_questions, correct_count, score, time_taken) VALUES
('2025-10-13 14:00:00', 'short_answer', 20, 16, 80.0, 600),
('2025-10-13 15:30:00', 'multiple_choice', 30, 25, 83.33, 450);

4.5 exam_details (시험 문제 상세)
용도: 시험의 각 문제별 상세 정보 기록
컬럼명한글명데이터타입제약조건기본값설명detail_id상세IDINTEGERPRIMARY KEY AUTOINCREMENT-고유 식별자exam_id시험IDINTEGERNOT NULL FOREIGN KEY-exam_history.exam_id 참조word_id단어IDINTEGERNOT NULL FOREIGN KEY-words.word_id 참조question_number문제번호INTEGERNOT NULL CHECK(question_number > 0)-문제 순서user_answer사용자답변TEXTNULLNULL사용자가 입력한 답is_correct정답여부INTEGERNOT NULL CHECK(is_correct IN (0,1))-0:오답, 1:정답response_time응답시간REALNULLNULL초 단위
외래 키 제약조건:
sqlFOREIGN KEY (exam_id) REFERENCES exam_history(exam_id) ON DELETE CASCADE ON UPDATE CASCADE
FOREIGN KEY (word_id) REFERENCES words(word_id) ON DELETE CASCADE ON UPDATE CASCADE
복합 UNIQUE 제약조건:
sqlUNIQUE(exam_id, question_number)
인덱스:
sqlCREATE INDEX idx_detail_exam ON exam_details(exam_id);
CREATE INDEX idx_detail_word ON exam_details(word_id);
CREATE INDEX idx_detail_correct ON exam_details(is_correct);
샘플 데이터:
sqlINSERT INTO exam_details (exam_id, word_id, question_number, user_answer, is_correct, response_time) VALUES
(1, 1, 1, '사과', 1, 2.5),
(1, 2, 2, '책', 1, 3.0),
(1, 3, 3, '컴퓨터', 0, 8.5);
오답 문제 조회 쿼리:
sqlSELECT 
    ed.question_number,
    w.english,
    w.korean,
    ed.user_answer,
    ed.is_correct
FROM exam_details ed
JOIN words w ON ed.word_id = w.word_id
WHERE ed.exam_id = 1 AND ed.is_correct = 0
ORDER BY ed.question_number;

4.6 wrong_note (오답 노트)
용도: 틀린 단어를 관리하고 복습 대상 추적
컬럼명한글명데이터타입제약조건기본값설명note_id노트IDINTEGERPRIMARY KEY AUTOINCREMENT-고유 식별자word_id단어IDINTEGERNOT NULL FOREIGN KEY-words.word_id 참조exam_id시험IDINTEGERNULL FOREIGN KEYNULLexam_history.exam_id 참조added_date추가날짜TEXTNOT NULL-ISO 8601 형식is_resolved해결여부INTEGERNOT NULL CHECK(is_resolved IN (0,1))00:미해결, 1:해결
외래 키 제약조건:
sqlFOREIGN KEY (word_id) REFERENCES words(word_id) ON DELETE CASCADE ON UPDATE CASCADE
FOREIGN KEY (exam_id) REFERENCES exam_history(exam_id) ON DELETE SET NULL ON UPDATE CASCADE
복합 UNIQUE 제약조건:
sqlUNIQUE(word_id, exam_id)
동일 시험에서 같은 단어 중복 방지
인덱스:
sqlCREATE INDEX idx_note_word ON wrong_note(word_id);
CREATE INDEX idx_note_exam ON wrong_note(exam_id);
CREATE INDEX idx_note_resolved ON wrong_note(is_resolved);
CREATE INDEX idx_note_date ON wrong_note(added_date);
샘플 데이터:
sqlINSERT INTO wrong_note (word_id, exam_id, added_date, is_resolved) VALUES
(3, 1, '2025-10-13 14:30:00', 0),
(5, 1, '2025-10-13 14:30:00', 0);
미해결 오답 조회 쿼리:
sqlSELECT 
    w.english,
    w.korean,
    wn.added_date,
    ws.wrong_count,
    ws.total_attempts
FROM wrong_note wn
JOIN words w ON wn.word_id = w.word_id
LEFT JOIN word_statistics ws ON w.word_id = ws.word_id
WHERE wn.is_resolved = 0
ORDER BY ws.wrong_count DESC, wn.added_date DESC;

4.7 user_settings (사용자 설정)
용도: 사용자별 설정 및 목표 관리
컬럼명한글명데이터타입제약조건기본값설명setting_key설정키TEXTPRIMARY KEY-설정 항목 이름setting_value설정값TEXTNOT NULL-설정 값 (JSON 또는 문자열)updated_at수정일시TEXTNOT NULL-ISO 8601 형식
인덱스:
sqlCREATE INDEX idx_settings_updated ON user_settings(updated_at);
샘플 데이터:
sqlINSERT INTO user_settings (setting_key, setting_value, updated_at) VALUES
('daily_word_goal', '50', '2025-10-13 10:00:00'),
('daily_time_goal', '30', '2025-10-13 10:00:00'),
('theme', 'light', '2025-10-13 10:00:00'),
('font_size', 'medium', '2025-10-13 10:00:00'),
('flashcard_time_limit', '10', '2025-10-13 10:00:00'),
('exam_time_limit', '600', '2025-10-13 10:00:00'),
('language', 'ko', '2025-10-13 10:00:00');
설정값 정의:
setting_key설명가능한 값기본값daily_word_goal일일 학습 단어 목표숫자 (개)50daily_time_goal일일 학습 시간 목표숫자 (분)30theme테마light, darklightfont_size폰트 크기small, medium, largemediumflashcard_time_limit플래시카드 제한시간숫자 (초), 0=무제한10exam_time_limit시험 제한시간숫자 (초), 0=무제한600language인터페이스 언어ko, enko
설정 조회/업데이트 쿼리:
sql-- 조회
SELECT setting_value FROM user_settings WHERE setting_key = 'daily_word_goal';

-- 업데이트
INSERT OR REPLACE INTO user_settings (setting_key, setting_value, updated_at)
VALUES ('daily_word_goal', '100', datetime('now'));

5. 데이터베이스 생성 DDL
5.1 전체 스키마 생성 스크립트
sql-- vocabulary.db 스키마 생성 스크립트
-- 작성일: 2025-10-13

PRAGMA foreign_keys = ON;
PRAGMA encoding = "UTF-8";

-- 1. words 테이블
CREATE TABLE IF NOT EXISTS words (
    word_id INTEGER PRIMARY KEY AUTOINCREMENT,
    english TEXT NOT NULL UNIQUE,
    korean TEXT NOT NULL,
    memo TEXT,
    is_favorite INTEGER NOT NULL DEFAULT 0 CHECK(is_favorite IN (0,1)),
    created_date TEXT NOT NULL,
    modified_date TEXT
);

CREATE INDEX idx_words_english ON words(english);
CREATE INDEX idx_words_favorite ON words(is_favorite);
CREATE INDEX idx_words_created ON words(created_date);


-- 2. learning_history 테이블
CREATE TABLE IF NOT EXISTS learning_history (
    history_id INTEGER PRIMARY KEY AUTOINCREMENT,
    word_id INTEGER NOT NULL,
    study_date TEXT NOT NULL,
    is_correct INTEGER NOT NULL CHECK(is_correct IN (0,1)),
    response_time REAL,
    study_type TEXT NOT NULL CHECK(study_type IN ('flashcard','exam')),
    FOREIGN KEY (word_id) REFERENCES words(word_id) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE INDEX idx_learning_word ON learning_history(word_id);
CREATE INDEX idx_learning_date ON learning_history(study_date);
CREATE INDEX idx_learning_type ON learning_history(study_type);
CREATE INDEX idx_learning_correct ON learning_history(is_correct);


-- 3. word_statistics 테이블
CREATE TABLE IF NOT EXISTS word_statistics (
    word_id INTEGER PRIMARY KEY,
    total_attempts INTEGER NOT NULL DEFAULT 0 CHECK(total_attempts >= 0),
    correct_count INTEGER NOT NULL DEFAULT 0 CHECK(correct_count >= 0),
    wrong_count INTEGER NOT NULL DEFAULT 0 CHECK(wrong_count >= 0),
    last_study_date TEXT,
    next_review_date TEXT,
    ease_factor REAL NOT NULL DEFAULT 2.5 CHECK(ease_factor >= 1.3),
    interval_days INTEGER NOT NULL DEFAULT 0 CHECK(interval_days >= 0),
    FOREIGN KEY (word_id) REFERENCES words(word_id) ON DELETE CASCADE ON UPDATE CASCADE
);

CREATE INDEX idx_stats_last_study ON word_statistics(last_study_date);
CREATE INDEX idx_stats_next_review ON word_statistics(next_review_date);
CREATE INDEX idx_stats_wrong_rate ON word_statistics(wrong_count, total_attempts);


-- 4. exam_history 테이블
CREATE TABLE IF NOT EXISTS exam_history (
    exam_id INTEGER PRIMARY KEY AUTOINCREMENT,
    exam_date TEXT NOT NULL,
    exam_type TEXT NOT NULL CHECK(exam_type IN ('short_answer','multiple_choice')),
    total_questions INTEGER NOT NULL CHECK(total_questions > 0),
    correct_count INTEGER NOT NULL CHECK(correct_count >= 0),
    score REAL NOT NULL CHECK(score >= 0 AND score <= 100),
    time_taken INTEGER
);

CREATE INDEX idx_exam_date ON exam_history(exam_date);
CREATE INDEX idx_exam_type ON exam_history(exam_type);
CREATE INDEX idx_exam_score ON exam_history(score);


-- 5. exam_details 테이블
CREATE TABLE IF NOT EXISTS exam_details (
    detail_id INTEGER PRIMARY KEY AUTOINCREMENT,
    exam_id INTEGER NOT NULL,
    word_id INTEGER NOT NULL,
    question_number INTEGER NOT NULL CHECK(question_number > 0),
    user_answer TEXT,
    is_correct INTEGER NOT NULL CHECK(is_correct IN (0,1)),
    response_time REAL,
    FOREIGN KEY (exam_id) REFERENCES exam_history(exam_id) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (word_id) REFERENCES words(word_id) ON DELETE CASCADE ON UPDATE CASCADE,
    UNIQUE(exam_id, question_number)
);R계속sqlCREATE INDEX idx_detail_exam ON exam_details(exam_id);
CREATE INDEX idx_detail_word ON exam_details(word_id);
CREATE INDEX idx_detail_correct ON exam_details(is_correct);


-- 6. wrong_note 테이블
CREATE TABLE IF NOT EXISTS wrong_note (
    note_id INTEGER PRIMARY KEY AUTOINCREMENT,
    word_id INTEGER NOT NULL,
    exam_id INTEGER,
    added_date TEXT NOT NULL,
    is_resolved INTEGER NOT NULL DEFAULT 0 CHECK(is_resolved IN (0,1)),
    FOREIGN KEY (word_id) REFERENCES words(word_id) ON DELETE CASCADE ON UPDATE CASCADE,
    FOREIGN KEY (exam_id) REFERENCES exam_history(exam_id) ON DELETE SET NULL ON UPDATE CASCADE,
    UNIQUE(word_id, exam_id)
);

CREATE INDEX idx_note_word ON wrong_note(word_id);
CREATE INDEX idx_note_exam ON wrong_note(exam_id);
CREATE INDEX idx_note_resolved ON wrong_note(is_resolved);
CREATE INDEX idx_note_date ON wrong_note(added_date);


-- 7. user_settings 테이블
CREATE TABLE IF NOT EXISTS user_settings (
    setting_key TEXT PRIMARY KEY,
    setting_value TEXT NOT NULL,
    updated_at TEXT NOT NULL
);

CREATE INDEX idx_settings_updated ON user_settings(updated_at);


-- 8. 기본 설정값 삽입
INSERT OR IGNORE INTO user_settings (setting_key, setting_value, updated_at) VALUES
('daily_word_goal', '50', datetime('now')),
('daily_time_goal', '30', datetime('now')),
('theme', 'light', datetime('now')),
('font_size', 'medium', datetime('now')),
('flashcard_time_limit', '10', datetime('now')),
('exam_time_limit', '600', datetime('now')),
('language', 'ko', datetime('now'));

6. 트리거 설계
6.1 통계 자동 업데이트 트리거
목적: learning_history에 데이터 삽입 시 word_statistics 자동 업데이트
sql-- 학습 이력 삽입 시 통계 자동 업데이트 트리거
CREATE TRIGGER IF NOT EXISTS update_statistics_after_learning
AFTER INSERT ON learning_history
FOR EACH ROW
BEGIN
    -- word_statistics에 해당 단어가 없으면 삽입
    INSERT OR IGNORE INTO word_statistics (word_id)
    VALUES (NEW.word_id);
    
    -- 통계 업데이트
    UPDATE word_statistics
    SET 
        total_attempts = total_attempts + 1,
        correct_count = correct_count + NEW.is_correct,
        wrong_count = wrong_count + (1 - NEW.is_correct),
        last_study_date = NEW.study_date
    WHERE word_id = NEW.word_id;
END;
6.2 단어 삭제 시 관련 데이터 정리 트리거
목적: 단어 삭제 시 고아(orphan) 데이터 방지
sql-- 단어 삭제 시 통계 정리 트리거
CREATE TRIGGER IF NOT EXISTS cleanup_statistics_after_word_delete
AFTER DELETE ON words
FOR EACH ROW
BEGIN
    DELETE FROM word_statistics WHERE word_id = OLD.word_id;
END;
6.3 시험 종료 시 오답 노트 자동 생성 트리거
목적: 시험 문제에서 틀린 단어를 자동으로 오답 노트에 추가
sql-- 시험 문제 틀렸을 때 오답 노트 자동 추가 트리거
CREATE TRIGGER IF NOT EXISTS add_to_wrong_note_on_exam_fail
AFTER INSERT ON exam_details
FOR EACH ROW
WHEN NEW.is_correct = 0
BEGIN
    INSERT OR IGNORE INTO wrong_note (word_id, exam_id, added_date, is_resolved)
    VALUES (NEW.word_id, NEW.exam_id, datetime('now'), 0);
END;

7. 주요 조회 쿼리 예시
7.1 학습 통계 조회
오늘 학습 통계
sqlSELECT 
    COUNT(DISTINCT word_id) as words_studied,
    SUM(is_correct) as correct_count,
    COUNT(*) - SUM(is_correct) as wrong_count,
    ROUND(AVG(is_correct) * 100, 2) as accuracy_rate,
    SUM(response_time) as total_time
FROM learning_history
WHERE DATE(study_date) = DATE('now');
전체 학습 통계
sqlSELECT 
    COUNT(DISTINCT word_id) as total_words_studied,
    SUM(total_attempts) as total_attempts,
    SUM(correct_count) as total_correct,
    SUM(wrong_count) as total_wrong,
    ROUND((SUM(correct_count) * 100.0) / NULLIF(SUM(total_attempts), 0), 2) as overall_accuracy
FROM word_statistics;
단어 숙지도 분류
sqlSELECT 
    COUNT(CASE WHEN wrong_rate >= 70 THEN 1 END) as weak_words,
    COUNT(CASE WHEN wrong_rate >= 40 AND wrong_rate < 70 THEN 1 END) as moderate_words,
    COUNT(CASE WHEN wrong_rate < 40 AND total_attempts >= 3 THEN 1 END) as strong_words,
    COUNT(CASE WHEN total_attempts < 3 THEN 1 END) as new_words
FROM (
    SELECT 
        word_id,
        total_attempts,
        CASE 
            WHEN total_attempts = 0 THEN NULL
            ELSE (wrong_count * 100.0) / total_attempts
        END as wrong_rate
    FROM word_statistics
);
7.2 개인화 학습 조회
오답률 높은 단어 TOP 10
sqlSELECT 
    w.word_id,
    w.english,
    w.korean,
    ws.total_attempts,
    ws.wrong_count,
    ROUND((ws.wrong_count * 100.0) / ws.total_attempts, 2) as wrong_rate
FROM words w
JOIN word_statistics ws ON w.word_id = ws.word_id
WHERE ws.total_attempts >= 3
ORDER BY wrong_rate DESC, ws.total_attempts DESC
LIMIT 10;
복습 필요 단어 조회
sqlSELECT 
    w.word_id,
    w.english,
    w.korean,
    ws.next_review_date,
    JULIANDAY('now') - JULIANDAY(ws.last_study_date) as days_since_study
FROM words w
JOIN word_statistics ws ON w.word_id = ws.word_id
WHERE ws.next_review_date <= DATE('now')
   OR ws.next_review_date IS NULL
ORDER BY ws.next_review_date ASC, days_since_study DESC;
개인화 가중치 계산
sqlSELECT 
    w.word_id,
    w.english,
    w.korean,
    ws.total_attempts,
    ROUND((ws.wrong_count * 100.0) / NULLIF(ws.total_attempts, 0), 2) as wrong_rate,
    JULIANDAY('now') - JULIANDAY(ws.last_study_date) as days_since_study,
    -- 가중치 계산
    CASE
        WHEN ws.total_attempts < 3 THEN 1.5  -- 신규 단어
        WHEN (ws.wrong_count * 100.0) / ws.total_attempts >= 70 THEN 3.0  -- 취약
        WHEN (ws.wrong_count * 100.0) / ws.total_attempts >= 40 THEN 2.0  -- 주의
        ELSE 1.0  -- 양호
    END as base_weight,
    -- 복습 지연 가중치
    CASE
        WHEN JULIANDAY('now') - JULIANDAY(ws.last_study_date) >= 7 THEN 2.0
        WHEN JULIANDAY('now') - JULIANDAY(ws.last_study_date) >= 3 THEN 1.5
        ELSE 1.0
    END as delay_weight
FROM words w
LEFT JOIN word_statistics ws ON w.word_id = ws.word_id
ORDER BY (base_weight * delay_weight) DESC;
7.3 시험 관련 조회
최근 시험 결과
sqlSELECT 
    exam_id,
    exam_date,
    exam_type,
    total_questions,
    correct_count,
    score,
    time_taken
FROM exam_history
ORDER BY exam_date DESC
LIMIT 10;
시험 성적 추이
sqlSELECT 
    DATE(exam_date) as exam_day,
    AVG(score) as avg_score,
    COUNT(*) as exam_count
FROM exam_history
GROUP BY DATE(exam_date)
ORDER BY exam_day DESC
LIMIT 30;
특정 시험의 상세 결과
sqlSELECT 
    ed.question_number,
    w.english,
    w.korean,
    ed.user_answer,
    CASE ed.is_correct 
        WHEN 1 THEN '정답' 
        ELSE '오답' 
    END as result,
    ed.response_time
FROM exam_details ed
JOIN words w ON ed.word_id = w.word_id
WHERE ed.exam_id = ?
ORDER BY ed.question_number;
7.4 오답 노트 조회
미해결 오답 목록
sqlSELECT 
    w.word_id,
    w.english,
    w.korean,
    wn.added_date,
    ws.wrong_count,
    ws.total_attempts,
    ROUND((ws.wrong_count * 100.0) / NULLIF(ws.total_attempts, 0), 2) as wrong_rate
FROM wrong_note wn
JOIN words w ON wn.word_id = w.word_id
LEFT JOIN word_statistics ws ON w.word_id = ws.word_id
WHERE wn.is_resolved = 0
ORDER BY ws.wrong_count DESC, wn.added_date ASC;
시험별 오답 통계
sqlSELECT 
    eh.exam_id,
    eh.exam_date,
    eh.exam_type,
    COUNT(wn.note_id) as wrong_count,
    COUNT(CASE WHEN wn.is_resolved = 1 THEN 1 END) as resolved_count,
    COUNT(CASE WHEN wn.is_resolved = 0 THEN 1 END) as unresolved_count
FROM exam_history eh
LEFT JOIN wrong_note wn ON eh.exam_id = wn.exam_id
GROUP BY eh.exam_id
ORDER BY eh.exam_date DESC;
7.5 연속 학습일 (스트릭) 계산
sql-- 연속 학습일 계산 (복잡한 로직이므로 애플리케이션 레벨에서 처리 권장)
WITH study_days AS (
    SELECT DISTINCT DATE(study_date) as study_day
    FROM learning_history
    ORDER BY study_day DESC
),
streak_check AS (
    SELECT 
        study_day,
        ROW_NUMBER() OVER (ORDER BY study_day DESC) as row_num,
        JULIANDAY(study_day) as julian_day
    FROM study_days
)
SELECT 
    COUNT(*) as current_streak
FROM streak_check
WHERE JULIANDAY('now') - julian_day = row_num - 1;

8. 데이터 무결성 검증 쿼리
8.1 통계 일관성 검증
sql-- word_statistics의 카운트가 learning_history와 일치하는지 확인
SELECT 
    ws.word_id,
    ws.total_attempts as stats_total,
    COUNT(lh.history_id) as history_total,
    ws.correct_count as stats_correct,
    SUM(lh.is_correct) as history_correct
FROM word_statistics ws
LEFT JOIN learning_history lh ON ws.word_id = lh.word_id
GROUP BY ws.word_id
HAVING stats_total != history_total OR stats_correct != history_correct;
8.2 고아 레코드 검증
sql-- words 테이블에 없는 word_id를 참조하는 레코드 찾기
SELECT 'learning_history' as table_name, COUNT(*) as orphan_count
FROM learning_history lh
LEFT JOIN words w ON lh.word_id = w.word_id
WHERE w.word_id IS NULL
UNION ALL
SELECT 'word_statistics', COUNT(*)
FROM word_statistics ws
LEFT JOIN words w ON ws.word_id = w.word_id
WHERE w.word_id IS NULL;

9. 성능 최적화 전략
9.1 인덱스 효과 분석
sql-- EXPLAIN QUERY PLAN을 사용하여 쿼리 실행 계획 확인
EXPLAIN QUERY PLAN
SELECT w.english, w.korean, ws.wrong_count
FROM words w
JOIN word_statistics ws ON w.word_id = ws.word_id
WHERE ws.wrong_count > 5
ORDER BY ws.wrong_count DESC;
9.2 대용량 데이터 처리

단어 10,000개 기준 예상 데이터 크기

words: ~1MB
learning_history: ~10MB (평균 10회 학습)
word_statistics: ~1MB
총 예상: 15-20MB



권장 사항:

VACUUM 명령으로 정기적 DB 최적화
ANALYZE 명령으로 통계 정보 갱신
오래된 learning_history 아카이빙 (1년 이상)

sql-- DB 최적화
VACUUM;
ANALYZE;

-- 오래된 학습 이력 아카이빙 (선택적)
DELETE FROM learning_history
WHERE study_date < datetime('now', '-1 year');

10. 백업 및 복구 전략
10.1 자동 백업 스크립트 (Python 예시)
pythonimport sqlite3
import shutil
from datetime import datetime
import os

def backup_database(source_db='data/vocabulary.db', 
                    backup_dir='data/backups/'):
    # 백업 디렉토리 생성
    os.makedirs(backup_dir, exist_ok=True)
    
    # 백업 파일명 생성
    timestamp = datetime.now().strftime('%Y%m%d')
    backup_file = f"{backup_dir}vocabulary_backup_{timestamp}.db"
    
    # 백업 수행
    shutil.copy2(source_db, backup_file)
    
    # 7일 이상 된 백업 파일 삭제
    for file in os.listdir(backup_dir):
        file_path = os.path.join(backup_dir, file)
        if os.path.isfile(file_path):
            file_age = datetime.now() - datetime.fromtimestamp(os.path.getmtime(file_path))
            if file_age.days > 7:
                os.remove(file_path)
10.2 복구 프로세스
pythondef restore_database(backup_file, target_db='data/vocabulary.db'):
    # 현재 DB 백업
    current_backup = f"{target_db}.before_restore"
    shutil.copy2(target_db, current_backup)
    
    # 복구 수행
    try:
        shutil.copy2(backup_file, target_db)
        print("복구 완료")
    except Exception as e:
        # 복구 실패 시 원본 복원
        shutil.copy2(current_backup, target_db)
        print(f"복구 실패: {e}")

11. 스키마 버전 관리
11.1 스키마 버전 테이블
sqlCREATE TABLE IF NOT EXISTS schema_version (
    version INTEGER PRIMARY KEY,
    applied_at TEXT NOT NULL,
    description TEXT
);

INSERT INTO schema_version (version, applied_at, description)
VALUES (1, datetime('now'), 'Initial schema creation');
11.2 마이그레이션 예시
sql-- v2: 단어에 발음 정보 추가
ALTER TABLE words ADD COLUMN pronunciation TEXT;

UPDATE schema_version SET version = 2, applied_at = datetime('now'),
description = 'Added pronunciation column to words table';

12. 데이터 검증 규칙
12.1 삽입 전 검증 사항

words 테이블

english: 빈 문자열 불가, 최대 100자
korean: 빈 문자열 불가, 최대 500자
is_favorite: 0 또는 1만 허용


learning_history 테이블

word_id: words 테이블에 존재해야 함
is_correct: 0 또는 1만 허용
response_time: 0 이상의 값


word_statistics 테이블

total_attempts = correct_count + wrong_count
ease_factor: 1.3 이상
interval_days: 0 이상



12.2 비즈니스 로직 검증
pythondef validate_word_data(english, korean):
    if not english or not korean:
        raise ValueError("영어와 한국어 모두 입력해야 합니다")
    if len(english) > 100:
        raise ValueError("영어 단어는 100자를 초과할 수 없습니다")
    if len(korean) > 500:
        raise ValueError("한국어 뜻은 500자를 초과할 수 없습니다")
    return True

def validate_statistics_consistency(total, correct, wrong):
    if total != correct + wrong:
        raise ValueError("통계 불일치: total_attempts != correct + wrong")
    return True

13. 문서 변경 이력
버전날짜변경 내용작성자v1.02025-10-13초안 작성AI Software Student Team

문서 끝
이 데이터베이스 스키마 설계서는 단어장 프로그램의 모든 데이터 구조를 정의하며, 향후 개발의 기준이 됩니다.